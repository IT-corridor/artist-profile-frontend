import { useMemo, cloneElement, forwardRef, createElement, useCallback, Fragment, useRef, useState } from 'react';
import classNames from 'classnames';
import nanoid from 'nanoid';

const useIcon = (icon) => {
    return useMemo(() => {
        if (icon) {
            let type = 'icon';
            if (icon.type === 'img') {
                type = 'image';
            }
            else if (icon.type === 'svg') {
                type = 'svg';
            }
            return {
                iconType: type,
                icon: cloneElement(icon, {
                    ...icon.props,
                    className: classNames(icon.props.className, 'icon'),
                }),
            };
        }
        return {};
    }, [icon]);
};

const isBoolean = (value) => typeof value === 'undefined';
const getChecked = (args) => {
    const { disabled, locked, state, value, type } = args;
    if (disabled || locked) {
        return false;
    }
    if (Array.isArray(state)) {
        return state.indexOf(value) !== -1;
    }
    if (isBoolean(value)) {
        return !!state;
    }
    if (type === 'radio') {
        return state === value;
    }
    return state;
};
const isDefaultStyle = (animation, icon) => {
    if (animation === 'tada' ||
        animation === 'jelly' ||
        animation === 'rotate' ||
        animation === 'pulse') {
        return false;
    }
    return !icon;
};
const getClassNames = ({ animation, icon, locked, bigger, plain, shape, fill, className, readOnly, isSwitch, iconType, }) => classNames('pretty', {
    'p-switch': isSwitch,
    'p-default': !isSwitch && isDefaultStyle(animation, icon),
    'p-locked': locked || readOnly,
    'p-bigger': bigger,
    'p-plain': plain,
    [`p-${shape}`]: shape,
    [`p-${fill}`]: fill,
    [`p-${animation}`]: animation,
    [`p-${iconType}`]: iconType,
}, className);

const PrettyInput = forwardRef(({ onChange, disabled, value, state, locked, type, name, checked, defaultChecked, defaultValue, baseId, }, ref) => {
    return (createElement("input", { onChange: onChange, type: type, value: value, name: name, id: baseId, tabIndex: -1, ref: ref, defaultChecked: defaultChecked, defaultValue: defaultValue, checked: typeof checked === 'undefined'
            ? getChecked({ state, value, disabled, locked, type })
            : checked, disabled: disabled }));
});
PrettyInput.displayName = 'Pretty.Input';

const PrettyLabel = ({ color, icon, children, baseId, }) => (createElement("div", { className: classNames('state', {
        [`p-${color}`]: color,
    }) },
    icon,
    createElement("label", { htmlFor: baseId }, children)));
PrettyLabel.displayName = 'Pretty.Label';

const getInputProps = (props) => {
    const { onChange, disabled, value, state, locked, type, name, checked, baseId, defaultValue, defaultChecked } = props;
    return { onChange, disabled, value, state, locked, type, name, checked, baseId, defaultValue, defaultChecked };
};
const getLabelProps = (props) => {
    const { children, baseId, color, icon } = props;
    return { children, baseId, color, icon };
};
const getHTMLProps = (props, exclude) => {
    const htmlProps = {};
    const propKeys = Object.keys(props);
    for (let i = 0; i < propKeys.length; i++) {
        if (!exclude.has(propKeys[i])) {
            htmlProps[propKeys[i]] = props[propKeys[i]];
        }
    }
    return htmlProps;
};
/**
 * A fairly gross way of organizing props so we don't unintentionally pass
 * props to native HTML elements.
 */
const organizeProps = (props) => {
    const { animation, bigger, plain, shape, fill, iconType, isSwitch, setState, className, ...rest } = props;
    const pcrProps = { animation, bigger, plain, shape, fill, iconType, isSwitch, setState, className };
    const inputProps = getInputProps(rest);
    const labelProps = getLabelProps(rest);
    const htmlProps = getHTMLProps(props, new Set([
        ...Object.keys(pcrProps),
        ...Object.keys(inputProps),
        ...Object.keys(labelProps),
    ]));
    return {
        pcrProps,
        inputProps,
        labelProps,
        htmlProps,
    };
};

const Pretty = forwardRef((props, ref) => {
    const { as = 'div', ...rest } = props;
    const { inputProps, labelProps, htmlProps } = organizeProps(rest);
    return createElement(as, {
        // @ts-ignore
        className: getClassNames(props),
        'aria-disabled': inputProps.disabled,
        'aria-checked': inputProps.state === 'indeterminate' ? 'mixed' : !!inputProps.state,
        tabIndex: inputProps.locked || inputProps.disabled ? -1 : 0,
        onKeyPress: useCallback(
        /* istanbul ignore next */ (e) => {
            /* istanbul ignore next */
            e.preventDefault();
        }, []),
        onKeyUp: useCallback((e) => {
            if ((e.keyCode === 32 || e.keyCode === 13) &&
                typeof inputProps.onChange === 'function') {
                inputProps.onChange(e, inputProps.value);
            }
        }, 
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [inputProps.onChange, inputProps.value]),
        role: inputProps.type,
        ...htmlProps,
    }, createElement(Fragment, null,
        createElement(PrettyInput, Object.assign({ ref: ref }, inputProps)),
        createElement(PrettyLabel, Object.assign({}, labelProps))));
});
Pretty.displayName = 'Pretty';

const PREFIX = 'pcr_';
const useUUID = ({ prefix = PREFIX } = {}) => {
    const { current: baseId } = useRef(prefix + nanoid(10));
    return { baseId };
};

const useCheckboxState = ({ state: initialState = false, } = {}) => {
    const [state, setState] = useState(initialState);
    return {
        state,
        setState,
        onChange: useCallback((e, args) => {
            const value = args || e.currentTarget.value;
            setState(state => {
                if (Array.isArray(state)) {
                    const index = state.indexOf(value);
                    if (index === -1) {
                        state.push(value);
                    }
                    else {
                        state.splice(index, 1);
                    }
                    return state.slice();
                }
                return !state;
            });
        }, []),
        ...useUUID(),
    };
};
const Checkbox = forwardRef(({ value: userValue, icon: userIcon, ...rest }, ref) => {
    const { icon, iconType } = useIcon(userIcon);
    const value = typeof userValue === 'undefined' ? '' : userValue;
    return createElement(Pretty, {
        type: 'checkbox',
        icon,
        iconType,
        value,
        ref,
        ...rest,
    });
});
Checkbox.displayName = 'Checkbox';

const Group = (props) => {
    // TODO: find a better way to filter through non-HTML attribute noise
    const { baseId, state, setState, onChange, ...propsWithoutState } = props;
    const { as = 'div', children, ...htmlProps } = propsWithoutState;
    return createElement(as, htmlProps, children);
};
Group.displayName = 'Group';

const useRadioState = ({ state: initialState = false } = {}) => {
    const [state, setState] = useState(initialState);
    return {
        state,
        setState,
        onChange: useCallback((e, args) => {
            const value = args || e.currentTarget.value;
            setState(prev => (isBoolean(prev) ? !prev : value));
        }, []),
        ...useUUID(),
    };
};
const RadioGroup = (props) => (createElement(Group, Object.assign({ as: "fieldset", role: "radiogroup" }, props)));
const Radio = forwardRef(({ value: userValue, icon: userIcon, shape = 'round', ...rest }, ref) => {
    const { icon, iconType } = useIcon(userIcon);
    const value = typeof userValue === 'undefined' ? '' : userValue;
    return createElement(Pretty, {
        type: 'radio',
        shape,
        icon,
        iconType,
        value,
        ref,
        ...rest,
    });
});
Radio.displayName = 'Radio';

const useSwitchState = ({ type = 'checkbox', state: initialState = false, } = {}) => {
    // TODO: might be an issue if the baseId changes if folks change from checkbox > radio
    const checkbox = useCheckboxState(initialState);
    const radio = useRadioState(initialState);
    return Object.assign({ type }, type === 'checkbox' ? checkbox : radio);
};
const Switch = forwardRef(({ value: userValue, ...rest }, ref) => {
    const value = typeof userValue === 'undefined' ? '' : userValue;
    return createElement(Pretty, {
        type: 'checkbox',
        isSwitch: true,
        value,
        ref,
        ...rest,
    });
});
Switch.displayName = 'Switch';

export { Checkbox, Group, Radio, RadioGroup, Switch, useCheckboxState, useRadioState, useSwitchState };
//# sourceMappingURL=index.js.map
