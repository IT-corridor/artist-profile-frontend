'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var classNames = _interopDefault(require('classnames'));
var nanoid = _interopDefault(require('nanoid'));

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

const useIcon = icon => {
  return React.useMemo(() => {
    if (icon) {
      let type = 'icon';

      if (icon.type === 'img') {
        type = 'image';
      } else if (icon.type === 'svg') {
        type = 'svg';
      }

      return {
        iconType: type,
        icon: React.cloneElement(icon, _objectSpread2({}, icon.props, {
          className: classNames(icon.props.className, 'icon')
        }))
      };
    }

    return {};
  }, [icon]);
};

const isBoolean = value => typeof value === 'undefined';
const getChecked = args => {
  const {
    disabled,
    locked,
    state,
    value,
    type
  } = args;

  if (disabled || locked) {
    return false;
  }

  if (Array.isArray(state)) {
    return state.indexOf(value) !== -1;
  }

  if (isBoolean(value)) {
    return !!state;
  }

  if (type === 'radio') {
    return state === value;
  }

  return state;
};
const isDefaultStyle = (animation, icon) => {
  if (animation === 'tada' || animation === 'jelly' || animation === 'rotate' || animation === 'pulse') {
    return false;
  }

  return !icon;
};
const getClassNames = ({
  animation,
  icon,
  locked,
  bigger,
  plain,
  shape,
  fill,
  className,
  readOnly,
  isSwitch,
  iconType
}) => classNames('pretty', {
  'p-switch': isSwitch,
  'p-default': !isSwitch && isDefaultStyle(animation, icon),
  'p-locked': locked || readOnly,
  'p-bigger': bigger,
  'p-plain': plain,
  [`p-${shape}`]: shape,
  [`p-${fill}`]: fill,
  [`p-${animation}`]: animation,
  [`p-${iconType}`]: iconType
}, className);

const PrettyInput = React.forwardRef(({
  onChange,
  disabled,
  value,
  state,
  locked,
  type,
  name,
  checked,
  defaultChecked,
  defaultValue,
  baseId
}, ref) => {
  return React.createElement("input", {
    onChange: onChange,
    type: type,
    value: value,
    name: name,
    id: baseId,
    tabIndex: -1,
    ref: ref,
    defaultChecked: defaultChecked,
    defaultValue: defaultValue,
    checked: typeof checked === 'undefined' ? getChecked({
      state,
      value,
      disabled,
      locked,
      type
    }) : checked,
    disabled: disabled
  });
});
PrettyInput.displayName = 'Pretty.Input';

const PrettyLabel = ({
  color,
  icon,
  children,
  baseId
}) => React.createElement("div", {
  className: classNames('state', {
    [`p-${color}`]: color
  })
}, icon, React.createElement("label", {
  htmlFor: baseId
}, children));
PrettyLabel.displayName = 'Pretty.Label';

const getInputProps = props => {
  const {
    onChange,
    disabled,
    value,
    state,
    locked,
    type,
    name,
    checked,
    baseId,
    defaultValue,
    defaultChecked
  } = props;
  return {
    onChange,
    disabled,
    value,
    state,
    locked,
    type,
    name,
    checked,
    baseId,
    defaultValue,
    defaultChecked
  };
};

const getLabelProps = props => {
  const {
    children,
    baseId,
    color,
    icon
  } = props;
  return {
    children,
    baseId,
    color,
    icon
  };
};

const getHTMLProps = (props, exclude) => {
  const htmlProps = {};
  const propKeys = Object.keys(props);

  for (let i = 0; i < propKeys.length; i++) {
    if (!exclude.has(propKeys[i])) {
      htmlProps[propKeys[i]] = props[propKeys[i]];
    }
  }

  return htmlProps;
};
/**
 * A fairly gross way of organizing props so we don't unintentionally pass
 * props to native HTML elements.
 */


const organizeProps = props => {
  const {
    animation,
    bigger,
    plain,
    shape,
    fill,
    iconType,
    isSwitch,
    setState,
    className
  } = props,
        rest = _objectWithoutProperties(props, ["animation", "bigger", "plain", "shape", "fill", "iconType", "isSwitch", "setState", "className"]);

  const pcrProps = {
    animation,
    bigger,
    plain,
    shape,
    fill,
    iconType,
    isSwitch,
    setState,
    className
  };
  const inputProps = getInputProps(rest);
  const labelProps = getLabelProps(rest);
  const htmlProps = getHTMLProps(props, new Set([...Object.keys(pcrProps), ...Object.keys(inputProps), ...Object.keys(labelProps)]));
  return {
    pcrProps,
    inputProps,
    labelProps,
    htmlProps
  };
};

const Pretty = React.forwardRef((props, ref) => {
  const {
    as = 'div'
  } = props,
        rest = _objectWithoutProperties(props, ["as"]);

  const {
    inputProps,
    labelProps,
    htmlProps
  } = organizeProps(rest);
  return React.createElement(as, _objectSpread2({
    // @ts-ignore
    className: getClassNames(props),
    'aria-disabled': inputProps.disabled,
    'aria-checked': inputProps.state === 'indeterminate' ? 'mixed' : !!inputProps.state,
    tabIndex: inputProps.locked || inputProps.disabled ? -1 : 0,
    onKeyPress: React.useCallback(
    /* istanbul ignore next */
    e => {
      /* istanbul ignore next */
      e.preventDefault();
    }, []),
    onKeyUp: React.useCallback(e => {
      if ((e.keyCode === 32 || e.keyCode === 13) && typeof inputProps.onChange === 'function') {
        inputProps.onChange(e, inputProps.value);
      }
    }, // eslint-disable-next-line react-hooks/exhaustive-deps
    [inputProps.onChange, inputProps.value]),
    role: inputProps.type
  }, htmlProps), React.createElement(React.Fragment, null, React.createElement(PrettyInput, Object.assign({
    ref: ref
  }, inputProps)), React.createElement(PrettyLabel, Object.assign({}, labelProps))));
});
Pretty.displayName = 'Pretty';

const PREFIX = 'pcr_';
const useUUID = ({
  prefix = PREFIX
} = {}) => {
  const {
    current: baseId
  } = React.useRef(prefix + nanoid(10));
  return {
    baseId
  };
};

const useCheckboxState = ({
  state: initialState = false
} = {}) => {
  const [state, setState] = React.useState(initialState);
  return _objectSpread2({
    state,
    setState,
    onChange: React.useCallback((e, args) => {
      const value = args || e.currentTarget.value;
      setState(state => {
        if (Array.isArray(state)) {
          const index = state.indexOf(value);

          if (index === -1) {
            state.push(value);
          } else {
            state.splice(index, 1);
          }

          return state.slice();
        }

        return !state;
      });
    }, [])
  }, useUUID());
};
const Checkbox = React.forwardRef((_ref, ref) => {
  let {
    value: userValue,
    icon: userIcon
  } = _ref,
      rest = _objectWithoutProperties(_ref, ["value", "icon"]);

  const {
    icon,
    iconType
  } = useIcon(userIcon);
  const value = typeof userValue === 'undefined' ? '' : userValue;
  return React.createElement(Pretty, _objectSpread2({
    type: 'checkbox',
    icon,
    iconType,
    value,
    ref
  }, rest));
});
Checkbox.displayName = 'Checkbox';

const Group = props => {
  // TODO: find a better way to filter through non-HTML attribute noise
  const propsWithoutState = _objectWithoutProperties(props, ["baseId", "state", "setState", "onChange"]);

  const {
    as = 'div',
    children
  } = propsWithoutState,
        htmlProps = _objectWithoutProperties(propsWithoutState, ["as", "children"]);

  return React.createElement(as, htmlProps, children);
};
Group.displayName = 'Group';

const useRadioState = ({
  state: initialState = false
} = {}) => {
  const [state, setState] = React.useState(initialState);
  return _objectSpread2({
    state,
    setState,
    onChange: React.useCallback((e, args) => {
      const value = args || e.currentTarget.value;
      setState(prev => isBoolean(prev) ? !prev : value);
    }, [])
  }, useUUID());
};
const RadioGroup = props => React.createElement(Group, Object.assign({
  as: "fieldset",
  role: "radiogroup"
}, props));
const Radio = React.forwardRef((_ref, ref) => {
  let {
    value: userValue,
    icon: userIcon,
    shape = 'round'
  } = _ref,
      rest = _objectWithoutProperties(_ref, ["value", "icon", "shape"]);

  const {
    icon,
    iconType
  } = useIcon(userIcon);
  const value = typeof userValue === 'undefined' ? '' : userValue;
  return React.createElement(Pretty, _objectSpread2({
    type: 'radio',
    shape,
    icon,
    iconType,
    value,
    ref
  }, rest));
});
Radio.displayName = 'Radio';

const useSwitchState = ({
  type = 'checkbox',
  state: initialState = false
} = {}) => {
  // TODO: might be an issue if the baseId changes if folks change from checkbox > radio
  const checkbox = useCheckboxState(initialState);
  const radio = useRadioState(initialState);
  return Object.assign({
    type
  }, type === 'checkbox' ? checkbox : radio);
};
const Switch = React.forwardRef((_ref, ref) => {
  let {
    value: userValue
  } = _ref,
      rest = _objectWithoutProperties(_ref, ["value"]);

  const value = typeof userValue === 'undefined' ? '' : userValue;
  return React.createElement(Pretty, _objectSpread2({
    type: 'checkbox',
    isSwitch: true,
    value,
    ref
  }, rest));
});
Switch.displayName = 'Switch';

exports.Checkbox = Checkbox;
exports.Group = Group;
exports.Radio = Radio;
exports.RadioGroup = RadioGroup;
exports.Switch = Switch;
exports.useCheckboxState = useCheckboxState;
exports.useRadioState = useRadioState;
exports.useSwitchState = useSwitchState;
//# sourceMappingURL=index.js.map
